{
  "version": 3,
  "sources": ["../../@solana/wallet-adapter-base/src/adapter.ts", "../../@solana/wallet-adapter-base/src/errors.ts", "../../@solana/wallet-adapter-base/src/transaction.ts", "../../@solana/wallet-adapter-base/src/signer.ts", "../../@solana/wallet-adapter-base/src/types.ts", "../../@solana/wallet-adapter-phantom/src/adapter.ts"],
  "sourcesContent": ["import type { Connection, PublicKey, SendOptions, Signer, Transaction, TransactionSignature } from '@solana/web3.js';\r\nimport EventEmitter from 'eventemitter3';\r\nimport { type WalletError, WalletNotConnectedError } from './errors.js';\r\nimport type { SupportedTransactionVersions, TransactionOrVersionedTransaction } from './transaction.js';\r\n\r\nexport { EventEmitter };\r\n\r\nexport interface WalletAdapterEvents {\r\n    connect(publicKey: PublicKey): void;\r\n    disconnect(): void;\r\n    error(error: WalletError): void;\r\n    readyStateChange(readyState: WalletReadyState): void;\r\n}\r\n\r\nexport interface SendTransactionOptions extends SendOptions {\r\n    signers?: Signer[];\r\n}\r\n\r\n// WalletName is a nominal type that wallet adapters should use, e.g. `'MyCryptoWallet' as WalletName<'MyCryptoWallet'>`\r\n// https://medium.com/@KevinBGreene/surviving-the-typescript-ecosystem-branding-and-type-tagging-6cf6e516523d\r\nexport type WalletName<T extends string = string> = T & { __brand__: 'WalletName' };\r\n\r\nexport interface WalletAdapterProps<Name extends string = string> {\r\n    name: WalletName<Name>;\r\n    url: string;\r\n    icon: string;\r\n    readyState: WalletReadyState;\r\n    publicKey: PublicKey | null;\r\n    connecting: boolean;\r\n    connected: boolean;\r\n    supportedTransactionVersions?: SupportedTransactionVersions;\r\n\r\n    autoConnect(): Promise<void>;\r\n    connect(): Promise<void>;\r\n    disconnect(): Promise<void>;\r\n    sendTransaction(\r\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\r\n        connection: Connection,\r\n        options?: SendTransactionOptions\r\n    ): Promise<TransactionSignature>;\r\n}\r\n\r\nexport type WalletAdapter<Name extends string = string> = WalletAdapterProps<Name> & EventEmitter<WalletAdapterEvents>;\r\n\r\n/**\r\n * A wallet's readiness describes a series of states that the wallet can be in,\r\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\r\n * extension like Phantom) might be `Installed` if we've found the Phantom API\r\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\r\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\r\n * metadata to personalize the wallet list for each user (eg. to show their\r\n * installed wallets first).\r\n */\r\nexport enum WalletReadyState {\r\n    /**\r\n     * User-installable wallets can typically be detected by scanning for an API\r\n     * that they've injected into the global context. If such an API is present,\r\n     * we consider the wallet to have been installed.\r\n     */\r\n    Installed = 'Installed',\r\n    NotDetected = 'NotDetected',\r\n    /**\r\n     * Loadable wallets are always available to you. Since you can load them at\r\n     * any time, it's meaningless to say that they have been detected.\r\n     */\r\n    Loadable = 'Loadable',\r\n    /**\r\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\r\n     * mobile) then it will stay in the `Unsupported` state.\r\n     */\r\n    Unsupported = 'Unsupported',\r\n}\r\n\r\nexport abstract class BaseWalletAdapter<Name extends string = string>\r\n    extends EventEmitter<WalletAdapterEvents>\r\n    implements WalletAdapter<Name>\r\n{\r\n    abstract name: WalletName<Name>;\r\n    abstract url: string;\r\n    abstract icon: string;\r\n    abstract readyState: WalletReadyState;\r\n    abstract publicKey: PublicKey | null;\r\n    abstract connecting: boolean;\r\n    abstract supportedTransactionVersions?: SupportedTransactionVersions;\r\n\r\n    get connected() {\r\n        return !!this.publicKey;\r\n    }\r\n\r\n    async autoConnect() {\r\n        await this.connect();\r\n    }\r\n\r\n    abstract connect(): Promise<void>;\r\n    abstract disconnect(): Promise<void>;\r\n\r\n    abstract sendTransaction(\r\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\r\n        connection: Connection,\r\n        options?: SendTransactionOptions\r\n    ): Promise<TransactionSignature>;\r\n\r\n    protected async prepareTransaction(\r\n        transaction: Transaction,\r\n        connection: Connection,\r\n        options: SendOptions = {}\r\n    ): Promise<Transaction> {\r\n        const publicKey = this.publicKey;\r\n        if (!publicKey) throw new WalletNotConnectedError();\r\n\r\n        transaction.feePayer = transaction.feePayer || publicKey;\r\n        transaction.recentBlockhash =\r\n            transaction.recentBlockhash ||\r\n            (\r\n                await connection.getLatestBlockhash({\r\n                    commitment: options.preflightCommitment,\r\n                    minContextSlot: options.minContextSlot,\r\n                })\r\n            ).blockhash;\r\n\r\n        return transaction;\r\n    }\r\n}\r\n\r\nexport function scopePollingDetectionStrategy(detect: () => boolean): void {\r\n    // Early return when server-side rendering\r\n    if (typeof window === 'undefined' || typeof document === 'undefined') return;\r\n\r\n    const disposers: (() => void)[] = [];\r\n\r\n    function detectAndDispose() {\r\n        const detected = detect();\r\n        if (detected) {\r\n            for (const dispose of disposers) {\r\n                dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Strategy #1: Try detecting every second.\r\n    const interval =\r\n        // TODO: #334 Replace with idle callback strategy.\r\n        setInterval(detectAndDispose, 1000);\r\n    disposers.push(() => clearInterval(interval));\r\n\r\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\r\n    if (\r\n        // Implies that `DOMContentLoaded` has not yet fired.\r\n        document.readyState === 'loading'\r\n    ) {\r\n        document.addEventListener('DOMContentLoaded', detectAndDispose, { once: true });\r\n        disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\r\n    }\r\n\r\n    // Strategy #3: Detect after the `window` has fully loaded.\r\n    if (\r\n        // If the `complete` state has been reached, we're too late.\r\n        document.readyState !== 'complete'\r\n    ) {\r\n        window.addEventListener('load', detectAndDispose, { once: true });\r\n        disposers.push(() => window.removeEventListener('load', detectAndDispose));\r\n    }\r\n\r\n    // Strategy #4: Detect synchronously, now.\r\n    detectAndDispose();\r\n}\r\n\r\n/**\r\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\r\n * if that wallet has a universal link configured to do so\r\n * But should not be redirected from within a webview, eg. if they're already\r\n * inside a wallet's browser\r\n * This function can be used to identify users who are on iOS and can be redirected\r\n *\r\n * @returns true if the user can be redirected\r\n */\r\nexport function isIosAndRedirectable() {\r\n    // SSR: return false\r\n    if (!navigator) return false;\r\n\r\n    const userAgent = navigator.userAgent.toLowerCase();\r\n\r\n    // if on iOS the user agent will contain either iPhone or iPad\r\n    // caveat: if requesting desktop site then this won't work\r\n    const isIos = userAgent.includes('iphone') || userAgent.includes('ipad');\r\n\r\n    // if in a webview then it will not include Safari\r\n    // note that other iOS browsers also include Safari\r\n    // so we will redirect only if Safari is also included\r\n    const isSafari = userAgent.includes('safari');\r\n\r\n    return isIos && isSafari;\r\n}\r\n", "export class WalletError extends Error {\r\n    error: any;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    constructor(message?: string, error?: any) {\r\n        super(message);\r\n        this.error = error;\r\n    }\r\n}\r\n\r\nexport class WalletNotReadyError extends WalletError {\r\n    name = 'WalletNotReadyError';\r\n}\r\n\r\nexport class WalletLoadError extends WalletError {\r\n    name = 'WalletLoadError';\r\n}\r\n\r\nexport class WalletConfigError extends WalletError {\r\n    name = 'WalletConfigError';\r\n}\r\n\r\nexport class WalletConnectionError extends WalletError {\r\n    name = 'WalletConnectionError';\r\n}\r\n\r\nexport class WalletDisconnectedError extends WalletError {\r\n    name = 'WalletDisconnectedError';\r\n}\r\n\r\nexport class WalletDisconnectionError extends WalletError {\r\n    name = 'WalletDisconnectionError';\r\n}\r\n\r\nexport class WalletAccountError extends WalletError {\r\n    name = 'WalletAccountError';\r\n}\r\n\r\nexport class WalletPublicKeyError extends WalletError {\r\n    name = 'WalletPublicKeyError';\r\n}\r\n\r\nexport class WalletKeypairError extends WalletError {\r\n    name = 'WalletKeypairError';\r\n}\r\n\r\nexport class WalletNotConnectedError extends WalletError {\r\n    name = 'WalletNotConnectedError';\r\n}\r\n\r\nexport class WalletSendTransactionError extends WalletError {\r\n    name = 'WalletSendTransactionError';\r\n}\r\n\r\nexport class WalletSignMessageError extends WalletError {\r\n    name = 'WalletSignMessageError';\r\n}\r\n\r\nexport class WalletSignTransactionError extends WalletError {\r\n    name = 'WalletSignTransactionError';\r\n}\r\n\r\nexport class WalletTimeoutError extends WalletError {\r\n    name = 'WalletTimeoutError';\r\n}\r\n\r\nexport class WalletWindowBlockedError extends WalletError {\r\n    name = 'WalletWindowBlockedError';\r\n}\r\n\r\nexport class WalletWindowClosedError extends WalletError {\r\n    name = 'WalletWindowClosedError';\r\n}\r\n", "import type { Transaction, TransactionVersion, VersionedTransaction } from '@solana/web3.js';\r\n\r\nexport type SupportedTransactionVersions = ReadonlySet<TransactionVersion> | null | undefined;\r\n\r\nexport type TransactionOrVersionedTransaction<S extends SupportedTransactionVersions> = S extends null | undefined\r\n    ? Transaction\r\n    : Transaction | VersionedTransaction;\r\n\r\nexport function isVersionedTransaction(\r\n    transaction: Transaction | VersionedTransaction\r\n): transaction is VersionedTransaction {\r\n    return 'version' in transaction;\r\n}\r\n", "import type { Connection, TransactionSignature } from '@solana/web3.js';\r\nimport {\r\n    BaseWalletAdapter,\r\n    type SendTransactionOptions,\r\n    type WalletAdapter,\r\n    type WalletAdapterProps,\r\n} from './adapter.js';\r\nimport { WalletSendTransactionError, WalletSignTransactionError } from './errors.js';\r\nimport { isVersionedTransaction, type TransactionOrVersionedTransaction } from './transaction.js';\r\n\r\nexport interface SignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\r\n    signTransaction<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\r\n        transaction: T\r\n    ): Promise<T>;\r\n    signAllTransactions<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\r\n        transactions: T[]\r\n    ): Promise<T[]>;\r\n}\r\n\r\nexport type SignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> & SignerWalletAdapterProps<Name>;\r\n\r\nexport abstract class BaseSignerWalletAdapter<Name extends string = string>\r\n    extends BaseWalletAdapter<Name>\r\n    implements SignerWalletAdapter<Name>\r\n{\r\n    async sendTransaction(\r\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\r\n        connection: Connection,\r\n        options: SendTransactionOptions = {}\r\n    ): Promise<TransactionSignature> {\r\n        let emit = true;\r\n        try {\r\n            if (isVersionedTransaction(transaction)) {\r\n                if (!this.supportedTransactionVersions)\r\n                    throw new WalletSendTransactionError(\r\n                        `Sending versioned transactions isn't supported by this wallet`\r\n                    );\r\n\r\n                if (!this.supportedTransactionVersions.has(transaction.version))\r\n                    throw new WalletSendTransactionError(\r\n                        `Sending transaction version ${transaction.version} isn't supported by this wallet`\r\n                    );\r\n\r\n                try {\r\n                    transaction = await this.signTransaction(transaction);\r\n\r\n                    const rawTransaction = transaction.serialize();\r\n\r\n                    return await connection.sendRawTransaction(rawTransaction, options);\r\n                } catch (error: any) {\r\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\r\n                    if (error instanceof WalletSignTransactionError) {\r\n                        emit = false;\r\n                        throw error;\r\n                    }\r\n                    throw new WalletSendTransactionError(error?.message, error);\r\n                }\r\n            } else {\r\n                try {\r\n                    const { signers, ...sendOptions } = options;\r\n\r\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\r\n\r\n                    signers?.length && transaction.partialSign(...signers);\r\n\r\n                    transaction = await this.signTransaction(transaction);\r\n\r\n                    const rawTransaction = transaction.serialize();\r\n\r\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\r\n                } catch (error: any) {\r\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\r\n                    if (error instanceof WalletSignTransactionError) {\r\n                        emit = false;\r\n                        throw error;\r\n                    }\r\n                    throw new WalletSendTransactionError(error?.message, error);\r\n                }\r\n            }\r\n        } catch (error: any) {\r\n            if (emit) {\r\n                this.emit('error', error);\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    abstract signTransaction<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\r\n        transaction: T\r\n    ): Promise<T>;\r\n\r\n    async signAllTransactions<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\r\n        transactions: T[]\r\n    ): Promise<T[]> {\r\n        for (const transaction of transactions) {\r\n            if (isVersionedTransaction(transaction)) {\r\n                if (!this.supportedTransactionVersions)\r\n                    throw new WalletSignTransactionError(\r\n                        `Signing versioned transactions isn't supported by this wallet`\r\n                    );\r\n\r\n                if (!this.supportedTransactionVersions.has(transaction.version))\r\n                    throw new WalletSignTransactionError(\r\n                        `Signing transaction version ${transaction.version} isn't supported by this wallet`\r\n                    );\r\n            }\r\n        }\r\n\r\n        const signedTransactions: T[] = [];\r\n        for (const transaction of transactions) {\r\n            signedTransactions.push(await this.signTransaction(transaction));\r\n        }\r\n        return signedTransactions;\r\n    }\r\n}\r\n\r\nexport interface MessageSignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\r\n    signMessage(message: Uint8Array): Promise<Uint8Array>;\r\n}\r\n\r\nexport type MessageSignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> &\r\n    MessageSignerWalletAdapterProps<Name>;\r\n\r\nexport abstract class BaseMessageSignerWalletAdapter<Name extends string = string>\r\n    extends BaseSignerWalletAdapter<Name>\r\n    implements MessageSignerWalletAdapter<Name>\r\n{\r\n    abstract signMessage(message: Uint8Array): Promise<Uint8Array>;\r\n}\r\n", "import type { WalletAdapter } from './adapter.js';\r\nimport type { MessageSignerWalletAdapter, SignerWalletAdapter } from './signer.js';\r\nimport type { StandardWalletAdapter } from './standard.js';\r\n\r\nexport type Adapter = WalletAdapter | SignerWalletAdapter | MessageSignerWalletAdapter | StandardWalletAdapter;\r\n\r\nexport enum WalletAdapterNetwork {\r\n    Mainnet = 'mainnet-beta',\r\n    Testnet = 'testnet',\r\n    Devnet = 'devnet',\r\n}\r\n", "import type { EventEmitter, SendTransactionOptions, WalletName } from '@solana/wallet-adapter-base';\r\nimport {\r\n    BaseMessageSignerWalletAdapter,\r\n    isIosAndRedirectable,\r\n    isVersionedTransaction,\r\n    scopePollingDetectionStrategy,\r\n    WalletAccountError,\r\n    WalletConnectionError,\r\n    WalletDisconnectedError,\r\n    WalletDisconnectionError,\r\n    WalletError,\r\n    WalletNotConnectedError,\r\n    WalletNotReadyError,\r\n    WalletPublicKeyError,\r\n    WalletReadyState,\r\n    WalletSendTransactionError,\r\n    WalletSignMessageError,\r\n    WalletSignTransactionError,\r\n} from '@solana/wallet-adapter-base';\r\nimport type {\r\n    Connection,\r\n    SendOptions,\r\n    Transaction,\r\n    TransactionSignature,\r\n    TransactionVersion,\r\n    VersionedTransaction,\r\n} from '@solana/web3.js';\r\nimport { PublicKey } from '@solana/web3.js';\r\n\r\ninterface PhantomWalletEvents {\r\n    connect(...args: unknown[]): unknown;\r\n    disconnect(...args: unknown[]): unknown;\r\n    accountChanged(newPublicKey: PublicKey): unknown;\r\n}\r\n\r\ninterface PhantomWallet extends EventEmitter<PhantomWalletEvents> {\r\n    isPhantom?: boolean;\r\n    publicKey?: { toBytes(): Uint8Array };\r\n    isConnected: boolean;\r\n    signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T>;\r\n    signAllTransactions<T extends Transaction | VersionedTransaction>(transactions: T[]): Promise<T[]>;\r\n    signAndSendTransaction<T extends Transaction | VersionedTransaction>(\r\n        transaction: T,\r\n        options?: SendOptions\r\n    ): Promise<{ signature: TransactionSignature }>;\r\n    signMessage(message: Uint8Array): Promise<{ signature: Uint8Array }>;\r\n    connect(): Promise<void>;\r\n    disconnect(): Promise<void>;\r\n}\r\n\r\ninterface PhantomWindow extends Window {\r\n    phantom?: {\r\n        solana?: PhantomWallet;\r\n    };\r\n    solana?: PhantomWallet;\r\n}\r\n\r\ndeclare const window: PhantomWindow;\r\n\r\nexport interface PhantomWalletAdapterConfig {}\r\n\r\nexport const PhantomWalletName = 'Phantom' as WalletName<'Phantom'>;\r\n\r\nexport class PhantomWalletAdapter extends BaseMessageSignerWalletAdapter {\r\n    name = PhantomWalletName;\r\n    url = 'https://phantom.app';\r\n    icon =\r\n        'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjM0IiB3aWR0aD0iMzQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iLjUiIHgyPSIuNSIgeTE9IjAiIHkyPSIxIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiM1MzRiYjEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM1NTFiZjkiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9Ii41IiB4Mj0iLjUiIHkxPSIwIiB5Mj0iMSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9Ii44MiIvPjwvbGluZWFyR3JhZGllbnQ+PGNpcmNsZSBjeD0iMTciIGN5PSIxNyIgZmlsbD0idXJsKCNhKSIgcj0iMTciLz48cGF0aCBkPSJtMjkuMTcwMiAxNy4yMDcxaC0yLjk5NjljMC02LjEwNzQtNC45NjgzLTExLjA1ODE3LTExLjA5NzUtMTEuMDU4MTctNi4wNTMyNSAwLTEwLjk3NDYzIDQuODI5NTctMTEuMDk1MDggMTAuODMyMzctLjEyNDYxIDYuMjA1IDUuNzE3NTIgMTEuNTkzMiAxMS45NDUzOCAxMS41OTMyaC43ODM0YzUuNDkwNiAwIDEyLjg0OTctNC4yODI5IDEzLjk5OTUtOS41MDEzLjIxMjMtLjk2MTktLjU1MDItMS44NjYxLTEuNTM4OC0xLjg2NjF6bS0xOC41NDc5LjI3MjFjMCAuODE2Ny0uNjcwMzggMS40ODQ3LTEuNDkwMDEgMS40ODQ3LS44MTk2NCAwLTEuNDg5OTgtLjY2ODMtMS40ODk5OC0xLjQ4NDd2LTIuNDAxOWMwLS44MTY3LjY3MDM0LTEuNDg0NyAxLjQ4OTk4LTEuNDg0Ny44MTk2MyAwIDEuNDkwMDEuNjY4IDEuNDkwMDEgMS40ODQ3em01LjE3MzggMGMwIC44MTY3LS42NzAzIDEuNDg0Ny0xLjQ4OTkgMS40ODQ3LS44MTk3IDAtMS40OS0uNjY4My0xLjQ5LTEuNDg0N3YtMi40MDE5YzAtLjgxNjcuNjcwNi0xLjQ4NDcgMS40OS0xLjQ4NDcuODE5NiAwIDEuNDg5OS42NjggMS40ODk5IDEuNDg0N3oiIGZpbGw9InVybCgjYikiLz48L3N2Zz4K';\r\n    supportedTransactionVersions: ReadonlySet<TransactionVersion> = new Set(['legacy', 0]);\r\n\r\n    private _connecting: boolean;\r\n    private _wallet: PhantomWallet | null;\r\n    private _publicKey: PublicKey | null;\r\n    private _readyState: WalletReadyState =\r\n        typeof window === 'undefined' || typeof document === 'undefined'\r\n            ? WalletReadyState.Unsupported\r\n            : WalletReadyState.NotDetected;\r\n\r\n    constructor(config: PhantomWalletAdapterConfig = {}) {\r\n        super();\r\n        this._connecting = false;\r\n        this._wallet = null;\r\n        this._publicKey = null;\r\n\r\n        if (this._readyState !== WalletReadyState.Unsupported) {\r\n            if (isIosAndRedirectable()) {\r\n                // when in iOS (not webview), set Phantom as loadable instead of checking for install\r\n                this._readyState = WalletReadyState.Loadable;\r\n                this.emit('readyStateChange', this._readyState);\r\n            } else {\r\n                scopePollingDetectionStrategy(() => {\r\n                    if (window.phantom?.solana?.isPhantom || window.solana?.isPhantom) {\r\n                        this._readyState = WalletReadyState.Installed;\r\n                        this.emit('readyStateChange', this._readyState);\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    get publicKey() {\r\n        return this._publicKey;\r\n    }\r\n\r\n    get connecting() {\r\n        return this._connecting;\r\n    }\r\n\r\n    get readyState() {\r\n        return this._readyState;\r\n    }\r\n\r\n    async autoConnect(): Promise<void> {\r\n        // Skip autoconnect in the Loadable state\r\n        // We can't redirect to a universal link without user input\r\n        if (this.readyState === WalletReadyState.Installed) {\r\n            await this.connect();\r\n        }\r\n    }\r\n\r\n    async connect(): Promise<void> {\r\n        try {\r\n            if (this.connected || this.connecting) return;\r\n\r\n            if (this.readyState === WalletReadyState.Loadable) {\r\n                // redirect to the Phantom /browse universal link\r\n                // this will open the current URL in the Phantom in-wallet browser\r\n                const url = encodeURIComponent(window.location.href);\r\n                const ref = encodeURIComponent(window.location.origin);\r\n                window.location.href = `https://phantom.app/ul/browse/${url}?ref=${ref}`;\r\n                return;\r\n            }\r\n\r\n            if (this.readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();\r\n\r\n            this._connecting = true;\r\n\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            const wallet = window.phantom?.solana || window.solana!;\r\n\r\n            if (!wallet.isConnected) {\r\n                try {\r\n                    await wallet.connect();\r\n                } catch (error: any) {\r\n                    throw new WalletConnectionError(error?.message, error);\r\n                }\r\n            }\r\n\r\n            if (!wallet.publicKey) throw new WalletAccountError();\r\n\r\n            let publicKey: PublicKey;\r\n            try {\r\n                publicKey = new PublicKey(wallet.publicKey.toBytes());\r\n            } catch (error: any) {\r\n                throw new WalletPublicKeyError(error?.message, error);\r\n            }\r\n\r\n            wallet.on('disconnect', this._disconnected);\r\n            wallet.on('accountChanged', this._accountChanged);\r\n\r\n            this._wallet = wallet;\r\n            this._publicKey = publicKey;\r\n\r\n            this.emit('connect', publicKey);\r\n        } catch (error: any) {\r\n            this.emit('error', error);\r\n            throw error;\r\n        } finally {\r\n            this._connecting = false;\r\n        }\r\n    }\r\n\r\n    async disconnect(): Promise<void> {\r\n        const wallet = this._wallet;\r\n        if (wallet) {\r\n            wallet.off('disconnect', this._disconnected);\r\n            wallet.off('accountChanged', this._accountChanged);\r\n\r\n            this._wallet = null;\r\n            this._publicKey = null;\r\n\r\n            try {\r\n                await wallet.disconnect();\r\n            } catch (error: any) {\r\n                this.emit('error', new WalletDisconnectionError(error?.message, error));\r\n            }\r\n        }\r\n\r\n        this.emit('disconnect');\r\n    }\r\n\r\n    async sendTransaction<T extends Transaction | VersionedTransaction>(\r\n        transaction: T,\r\n        connection: Connection,\r\n        options: SendTransactionOptions = {}\r\n    ): Promise<TransactionSignature> {\r\n        try {\r\n            const wallet = this._wallet;\r\n            if (!wallet) throw new WalletNotConnectedError();\r\n\r\n            try {\r\n                const { signers, ...sendOptions } = options;\r\n\r\n                if (isVersionedTransaction(transaction)) {\r\n                    signers?.length && transaction.sign(signers);\r\n                } else {\r\n                    transaction = (await this.prepareTransaction(transaction, connection, sendOptions)) as T;\r\n                    signers?.length && (transaction as Transaction).partialSign(...signers);\r\n                }\r\n\r\n                sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;\r\n\r\n                const { signature } = await wallet.signAndSendTransaction(transaction, sendOptions);\r\n                return signature;\r\n            } catch (error: any) {\r\n                if (error instanceof WalletError) throw error;\r\n                throw new WalletSendTransactionError(error?.message, error);\r\n            }\r\n        } catch (error: any) {\r\n            this.emit('error', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async signTransaction<T extends Transaction | VersionedTransaction>(transaction: T): Promise<T> {\r\n        try {\r\n            const wallet = this._wallet;\r\n            if (!wallet) throw new WalletNotConnectedError();\r\n\r\n            try {\r\n                return (await wallet.signTransaction(transaction)) || transaction;\r\n            } catch (error: any) {\r\n                throw new WalletSignTransactionError(error?.message, error);\r\n            }\r\n        } catch (error: any) {\r\n            this.emit('error', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async signAllTransactions<T extends Transaction | VersionedTransaction>(transactions: T[]): Promise<T[]> {\r\n        try {\r\n            const wallet = this._wallet;\r\n            if (!wallet) throw new WalletNotConnectedError();\r\n\r\n            try {\r\n                return (await wallet.signAllTransactions(transactions)) || transactions;\r\n            } catch (error: any) {\r\n                throw new WalletSignTransactionError(error?.message, error);\r\n            }\r\n        } catch (error: any) {\r\n            this.emit('error', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async signMessage(message: Uint8Array): Promise<Uint8Array> {\r\n        try {\r\n            const wallet = this._wallet;\r\n            if (!wallet) throw new WalletNotConnectedError();\r\n\r\n            try {\r\n                const { signature } = await wallet.signMessage(message);\r\n                return signature;\r\n            } catch (error: any) {\r\n                throw new WalletSignMessageError(error?.message, error);\r\n            }\r\n        } catch (error: any) {\r\n            this.emit('error', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private _disconnected = () => {\r\n        const wallet = this._wallet;\r\n        if (wallet) {\r\n            wallet.off('disconnect', this._disconnected);\r\n            wallet.off('accountChanged', this._accountChanged);\r\n\r\n            this._wallet = null;\r\n            this._publicKey = null;\r\n\r\n            this.emit('error', new WalletDisconnectedError());\r\n            this.emit('disconnect');\r\n        }\r\n    };\r\n\r\n    private _accountChanged = (newPublicKey: PublicKey) => {\r\n        const publicKey = this._publicKey;\r\n        if (!publicKey) return;\r\n\r\n        try {\r\n            newPublicKey = new PublicKey(newPublicKey.toBytes());\r\n        } catch (error: any) {\r\n            this.emit('error', new WalletPublicKeyError(error?.message, error));\r\n            return;\r\n        }\r\n\r\n        if (publicKey.equals(newPublicKey)) return;\r\n\r\n        this._publicKey = newPublicKey;\r\n        this.emit('connect', newPublicKey);\r\n    };\r\n}\r\n"],
  "mappings": "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",
  "names": ["WalletReadyState", "EventEmitter", "WalletAdapterNetwork"]
}
