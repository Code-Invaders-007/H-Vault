import {
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  append_styles,
  assign,
  bind,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_space,
  claim_svg_element,
  compute_rest_props,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  safe_not_equal,
  set_svg_attributes,
  space,
  svg_element,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots
} from "./chunk-UJLIVLOQ.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/svelte-awesome/components/svg/Raw.svelte
var file = "node_modules/svelte-awesome/components/svg/Raw.svelte";
function create_fragment(ctx) {
  let g;
  const block = {
    c: function create() {
      g = svg_element("g");
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", {});
      var g_nodes = children(g);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(g, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      g.innerHTML = /*raw*/
      ctx[0];
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*raw*/
      1)
        g.innerHTML = /*raw*/
        ctx2[0];
      ;
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Raw", slots, []);
  let cursor = 870711;
  function getId() {
    cursor += 1;
    return `fa-${cursor.toString(16)}`;
  }
  let raw = "";
  let { data } = $$props;
  function getRaw(data2) {
    if (!data2 || !data2.raw) {
      return "";
    }
    let rawData = data2.raw;
    const ids = {};
    rawData = rawData.replace(/\s(?:xml:)?id=["']?([^"')\s]+)/g, (match, id) => {
      const uniqueId = getId();
      ids[id] = uniqueId;
      return ` id="${uniqueId}"`;
    });
    rawData = rawData.replace(/#(?:([^'")\s]+)|xpointer\(id\((['"]?)([^')]+)\2\)\))/g, (match, rawId, _, pointerId) => {
      const id = rawId || pointerId;
      if (!id || !ids[id]) {
        return match;
      }
      return `#${ids[id]}`;
    });
    return rawData;
  }
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Raw> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Raw> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ cursor, getId, raw, data, getRaw });
  $$self.$inject_state = ($$props2) => {
    if ("cursor" in $$props2)
      cursor = $$props2.cursor;
    if ("raw" in $$props2)
      $$invalidate(0, raw = $$props2.raw);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    2) {
      $:
        $$invalidate(0, raw = getRaw(data));
    }
  };
  return [raw, data];
}
var Raw = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { data: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Raw",
      options,
      id: create_fragment.name
    });
  }
  get data() {
    throw new Error("<Raw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Raw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Raw_default = Raw;

// node_modules/svelte-awesome/components/svg/Svg.svelte
var file2 = "node_modules/svelte-awesome/components/svg/Svg.svelte";
function add_css(target) {
  append_styles(target, "svelte-1mc5hvj", ".fa-icon.svelte-1mc5hvj{display:inline-block;fill:currentColor}.fa-flip-horizontal.svelte-1mc5hvj{transform:scale(-1, 1)}.fa-flip-vertical.svelte-1mc5hvj{transform:scale(1, -1)}.fa-spin.svelte-1mc5hvj{animation:svelte-1mc5hvj-fa-spin 1s 0s infinite linear}.fa-inverse.svelte-1mc5hvj{color:#fff}.fa-pulse.svelte-1mc5hvj{animation:svelte-1mc5hvj-fa-spin 1s infinite steps(8)}@keyframes svelte-1mc5hvj-fa-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZnLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFvQkUsdUJBQUEsQ0FDRSxPQUFBLENBQUEsWUFBcUIsQ0FDckIsSUFBQSxDQUFBLFlBQ0YsQ0FDQSxrQ0FBQSxDQUNFLFNBQUEsQ0FBQSxNQUFBLEVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FDRixDQUNBLGdDQUFBLENBQ0UsU0FBQSxDQUFBLE1BQUEsQ0FBQSxDQUFBLENBQUEsRUFBQSxDQUNGLENBQ0EsdUJBQUEsQ0FDRSxTQUFBLENBQUEsc0JBQUEsQ0FBQSxFQUFBLENBQUEsRUFBQSxDQUFBLFFBQUEsQ0FBQSxNQUNGLENBQ0EsMEJBQUEsQ0FDRSxLQUFBLENBQUEsSUFDRixDQUNBLHdCQUFBLENBQ0UsU0FBQSxDQUFBLHNCQUFBLENBQUEsRUFBQSxDQUFBLFFBQUEsQ0FBQSxNQUFBLENBQUEsQ0FDRixDQUNBLFdBQUEsc0JBQUEsQ0FDRSxFQUFBLENBQ0UsU0FBQSxDQUFBLE9BQUEsSUFBQSxDQUNGLENBQ0EsSUFBQSxDQUNFLFNBQUEsQ0FBQSxPQUFBLE1BQUEsQ0FDRixDQUNGIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlN2Zy5zdmVsdGUiXX0= */");
}
function create_fragment2(ctx) {
  let svg;
  let svg_class_value;
  let svg_role_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let svg_levels = [
    { version: "1.1" },
    {
      class: svg_class_value = "fa-icon " + /*className*/
      ctx[0]
    },
    { width: (
      /*width*/
      ctx[1]
    ) },
    { height: (
      /*height*/
      ctx[2]
    ) },
    { "aria-label": (
      /*label*/
      ctx[9]
    ) },
    {
      role: svg_role_value = /*label*/
      ctx[9] ? "img" : "presentation"
    },
    { viewBox: (
      /*box*/
      ctx[3]
    ) },
    { style: (
      /*style*/
      ctx[8]
    ) },
    /*$$restProps*/
    ctx[10]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        version: true,
        class: true,
        width: true,
        height: true,
        "aria-label": true,
        role: true,
        viewBox: true,
        style: true
      });
      var svg_nodes = children(svg);
      if (default_slot)
        default_slot.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(svg, svg_data);
      toggle_class(
        svg,
        "fa-spin",
        /*spin*/
        ctx[4]
      );
      toggle_class(
        svg,
        "fa-pulse",
        /*pulse*/
        ctx[6]
      );
      toggle_class(
        svg,
        "fa-inverse",
        /*inverse*/
        ctx[5]
      );
      toggle_class(
        svg,
        "fa-flip-horizontal",
        /*flip*/
        ctx[7] === "horizontal"
      );
      toggle_class(
        svg,
        "fa-flip-vertical",
        /*flip*/
        ctx[7] === "vertical"
      );
      toggle_class(svg, "svelte-1mc5hvj", true);
      add_location(svg, file2, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { version: "1.1" },
        (!current || dirty & /*className*/
        1 && svg_class_value !== (svg_class_value = "fa-icon " + /*className*/
        ctx2[0])) && { class: svg_class_value },
        (!current || dirty & /*width*/
        2) && { width: (
          /*width*/
          ctx2[1]
        ) },
        (!current || dirty & /*height*/
        4) && { height: (
          /*height*/
          ctx2[2]
        ) },
        (!current || dirty & /*label*/
        512) && { "aria-label": (
          /*label*/
          ctx2[9]
        ) },
        (!current || dirty & /*label*/
        512 && svg_role_value !== (svg_role_value = /*label*/
        ctx2[9] ? "img" : "presentation")) && { role: svg_role_value },
        (!current || dirty & /*box*/
        8) && { viewBox: (
          /*box*/
          ctx2[3]
        ) },
        (!current || dirty & /*style*/
        256) && { style: (
          /*style*/
          ctx2[8]
        ) },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      toggle_class(
        svg,
        "fa-spin",
        /*spin*/
        ctx2[4]
      );
      toggle_class(
        svg,
        "fa-pulse",
        /*pulse*/
        ctx2[6]
      );
      toggle_class(
        svg,
        "fa-inverse",
        /*inverse*/
        ctx2[5]
      );
      toggle_class(
        svg,
        "fa-flip-horizontal",
        /*flip*/
        ctx2[7] === "horizontal"
      );
      toggle_class(
        svg,
        "fa-flip-vertical",
        /*flip*/
        ctx2[7] === "vertical"
      );
      toggle_class(svg, "svelte-1mc5hvj", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "width", "height", "box", "spin", "inverse", "pulse", "flip", "style", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Svg", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { width } = $$props;
  let { height } = $$props;
  let { box = "0 0 0 0" } = $$props;
  let { spin = false } = $$props;
  let { inverse = false } = $$props;
  let { pulse = false } = $$props;
  let { flip = "none" } = $$props;
  let { style = "" } = $$props;
  let { label = "" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (width === void 0 && !("width" in $$props || $$self.$$.bound[$$self.$$.props["width"]])) {
      console.warn("<Svg> was created without expected prop 'width'");
    }
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<Svg> was created without expected prop 'height'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("width" in $$new_props)
      $$invalidate(1, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(2, height = $$new_props.height);
    if ("box" in $$new_props)
      $$invalidate(3, box = $$new_props.box);
    if ("spin" in $$new_props)
      $$invalidate(4, spin = $$new_props.spin);
    if ("inverse" in $$new_props)
      $$invalidate(5, inverse = $$new_props.inverse);
    if ("pulse" in $$new_props)
      $$invalidate(6, pulse = $$new_props.pulse);
    if ("flip" in $$new_props)
      $$invalidate(7, flip = $$new_props.flip);
    if ("style" in $$new_props)
      $$invalidate(8, style = $$new_props.style);
    if ("label" in $$new_props)
      $$invalidate(9, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    className,
    width,
    height,
    box,
    spin,
    inverse,
    pulse,
    flip,
    style,
    label
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("width" in $$props)
      $$invalidate(1, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(2, height = $$new_props.height);
    if ("box" in $$props)
      $$invalidate(3, box = $$new_props.box);
    if ("spin" in $$props)
      $$invalidate(4, spin = $$new_props.spin);
    if ("inverse" in $$props)
      $$invalidate(5, inverse = $$new_props.inverse);
    if ("pulse" in $$props)
      $$invalidate(6, pulse = $$new_props.pulse);
    if ("flip" in $$props)
      $$invalidate(7, flip = $$new_props.flip);
    if ("style" in $$props)
      $$invalidate(8, style = $$new_props.style);
    if ("label" in $$props)
      $$invalidate(9, label = $$new_props.label);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    width,
    height,
    box,
    spin,
    inverse,
    pulse,
    flip,
    style,
    label,
    $$restProps,
    $$scope,
    slots
  ];
}
var Svg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        class: 0,
        width: 1,
        height: 2,
        box: 3,
        spin: 4,
        inverse: 5,
        pulse: 6,
        flip: 7,
        style: 8,
        label: 9
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Svg",
      options,
      id: create_fragment2.name
    });
  }
  get class() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get box() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set box(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverse() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverse(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pulse() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pulse(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flip() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Svg_default = Svg;

// node_modules/svelte-awesome/components/Icon.svelte
var { console: console_1 } = globals;
var file3 = "node_modules/svelte-awesome/components/Icon.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*iconData*/
    ctx[6].paths && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*iconData*/
    ctx[6].polygons && create_if_block_2(ctx)
  );
  let if_block2 = (
    /*iconData*/
    ctx[6].raw && create_if_block_1(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*iconData*/
        ctx2[6].paths
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*iconData*/
        ctx2[6].polygons
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*iconData*/
        ctx2[6].raw
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*iconData*/
          64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(15:4) {#if iconData}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let each_1_anchor;
  let each_value_1 = (
    /*iconData*/
    ctx[6].paths
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*iconData*/
      64) {
        each_value_1 = /*iconData*/
        ctx2[6].paths;
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(16:6) {#if iconData.paths}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let path;
  let path_levels = [
    /*path*/
    ctx[30]
  ];
  let path_data = {};
  for (let i = 0; i < path_levels.length; i += 1) {
    path_data = assign(path_data, path_levels[i]);
  }
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {});
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(path, path_data);
      add_location(path, file3, 17, 10, 253);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(path, path_data = get_spread_update(path_levels, [dirty[0] & /*iconData*/
      64 && /*path*/
      ctx2[30]]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(17:8) {#each iconData.paths as path}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let each_1_anchor;
  let each_value = (
    /*iconData*/
    ctx[6].polygons
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*iconData*/
      64) {
        each_value = /*iconData*/
        ctx2[6].polygons;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(21:6) {#if iconData.polygons}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let polygon;
  let polygon_levels = [
    /*polygon*/
    ctx[27]
  ];
  let polygon_data = {};
  for (let i = 0; i < polygon_levels.length; i += 1) {
    polygon_data = assign(polygon_data, polygon_levels[i]);
  }
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {});
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(polygon, polygon_data);
      add_location(polygon, file3, 22, 10, 385);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(polygon, polygon_data = get_spread_update(polygon_levels, [dirty[0] & /*iconData*/
      64 && /*polygon*/
      ctx2[27]]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(22:8) {#each iconData.polygons as polygon}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let raw;
  let updating_data;
  let current;
  function raw_data_binding(value) {
    ctx[16](value);
  }
  let raw_props = {};
  if (
    /*iconData*/
    ctx[6] !== void 0
  ) {
    raw_props.data = /*iconData*/
    ctx[6];
  }
  raw = new Raw_default({ props: raw_props, $$inline: true });
  binding_callbacks.push(() => bind(raw, "data", raw_data_binding));
  const block = {
    c: function create() {
      create_component(raw.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(raw.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(raw, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const raw_changes = {};
      if (!updating_data && dirty[0] & /*iconData*/
      64) {
        updating_data = true;
        raw_changes.data = /*iconData*/
        ctx2[6];
        add_flush_callback(() => updating_data = false);
      }
      raw.$set(raw_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(raw.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(raw.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(raw, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(26:6) {#if iconData.raw}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*iconData*/
    ctx[6] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*iconData*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*iconData*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(14:8)      ",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*iconData*/
        64)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <Svg   {label}   {width}   {height}   {box}   style={combinedStyle}   {spin}   {flip}   {inverse}   {pulse}   class={className}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let svg;
  let current;
  const svg_spread_levels = [
    { label: (
      /*label*/
      ctx[5]
    ) },
    { width: (
      /*width*/
      ctx[7]
    ) },
    { height: (
      /*height*/
      ctx[8]
    ) },
    { box: (
      /*box*/
      ctx[10]
    ) },
    { style: (
      /*combinedStyle*/
      ctx[9]
    ) },
    { spin: (
      /*spin*/
      ctx[1]
    ) },
    { flip: (
      /*flip*/
      ctx[4]
    ) },
    { inverse: (
      /*inverse*/
      ctx[2]
    ) },
    { pulse: (
      /*pulse*/
      ctx[3]
    ) },
    { class: (
      /*className*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[11]
  ];
  let svg_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < svg_spread_levels.length; i += 1) {
    svg_props = assign(svg_props, svg_spread_levels[i]);
  }
  svg = new Svg_default({ props: svg_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = dirty[0] & /*label, width, height, box, combinedStyle, spin, flip, inverse, pulse, className, $$restProps*/
      4031 ? get_spread_update(svg_spread_levels, [
        dirty[0] & /*label*/
        32 && { label: (
          /*label*/
          ctx2[5]
        ) },
        dirty[0] & /*width*/
        128 && { width: (
          /*width*/
          ctx2[7]
        ) },
        dirty[0] & /*height*/
        256 && { height: (
          /*height*/
          ctx2[8]
        ) },
        dirty[0] & /*box*/
        1024 && { box: (
          /*box*/
          ctx2[10]
        ) },
        dirty[0] & /*combinedStyle*/
        512 && { style: (
          /*combinedStyle*/
          ctx2[9]
        ) },
        dirty[0] & /*spin*/
        2 && { spin: (
          /*spin*/
          ctx2[1]
        ) },
        dirty[0] & /*flip*/
        16 && { flip: (
          /*flip*/
          ctx2[4]
        ) },
        dirty[0] & /*inverse*/
        4 && { inverse: (
          /*inverse*/
          ctx2[2]
        ) },
        dirty[0] & /*pulse*/
        8 && { pulse: (
          /*pulse*/
          ctx2[3]
        ) },
        dirty[0] & /*className*/
        1 && { class: (
          /*className*/
          ctx2[0]
        ) },
        dirty[0] & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx2[11]
        )
      ]) : {};
      if (dirty[0] & /*$$scope, iconData*/
      131136) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function normaliseData(data) {
  let name;
  let iconData;
  if (!data) {
    return void 0;
  } else if ("definition" in data) {
    console.error("`import faIconName from '@fortawesome/package-name/faIconName` not supported - Please use `import { faIconName } from '@fortawesome/package-name/faIconName'` instead");
    return void 0;
  } else if ("iconName" in data && "icon" in data) {
    name = data.iconName;
    let paths = [];
    const [width, height, , , path] = data.icon;
    if (Array.isArray(path)) {
      paths = path;
    } else {
      paths = [path];
    }
    iconData = {
      width,
      height,
      paths: paths.map((path2) => {
        return { d: path2 };
      })
    };
  } else {
    name = Object.keys(data)[0];
    iconData = data[name];
  }
  return iconData;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "data", "scale", "spin", "inverse", "pulse", "flip", "label", "style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { data } = $$props;
  let iconData;
  let { scale = 1 } = $$props;
  let { spin = false } = $$props;
  let { inverse = false } = $$props;
  let { pulse = false } = $$props;
  let { flip = void 0 } = $$props;
  let { label = "" } = $$props;
  let { style = "" } = $$props;
  let childrenHeight = 0;
  let childrenWidth = 0;
  let outerScale = 1;
  let width = 10;
  let height = 10;
  let combinedStyle;
  let box;
  function normalisedScale() {
    let numScale = 1;
    if (typeof scale !== "undefined") {
      numScale = Number(scale);
    }
    if (isNaN(numScale) || numScale <= 0) {
      console.warn('Invalid prop: prop "scale" should be a number over 0.');
      return outerScale;
    }
    return numScale * outerScale;
  }
  function calculateBox() {
    if (iconData) {
      return `0 0 ${iconData.width} ${iconData.height}`;
    }
    return `0 0 ${width} ${height}`;
  }
  function calculateRatio() {
    if (!iconData) {
      return 1;
    }
    return Math.max(iconData.width, iconData.height) / 16;
  }
  function calculateWidth() {
    if (childrenWidth) {
      return childrenWidth;
    }
    if (iconData) {
      return iconData.width / calculateRatio() * normalisedScale();
    }
    return 0;
  }
  function calculateHeight() {
    if (childrenHeight) {
      return childrenHeight;
    }
    if (iconData) {
      return iconData.height / calculateRatio() * normalisedScale();
    }
    return 0;
  }
  function calculateStyle() {
    let combined = "";
    if (style !== null) {
      combined += style;
    }
    let size = normalisedScale();
    if (size === 1) {
      if (combined.length === 0) {
        return "";
      }
      return combined;
    }
    if (combined !== "" && !combined.endsWith(";")) {
      combined += "; ";
    }
    return `${combined}font-size: ${size}em`;
  }
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console_1.warn("<Icon> was created without expected prop 'data'");
    }
  });
  function raw_data_binding(value) {
    iconData = value;
    $$invalidate(6, iconData), $$invalidate(12, data), $$invalidate(14, style), $$invalidate(13, scale);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("data" in $$new_props)
      $$invalidate(12, data = $$new_props.data);
    if ("scale" in $$new_props)
      $$invalidate(13, scale = $$new_props.scale);
    if ("spin" in $$new_props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("inverse" in $$new_props)
      $$invalidate(2, inverse = $$new_props.inverse);
    if ("pulse" in $$new_props)
      $$invalidate(3, pulse = $$new_props.pulse);
    if ("flip" in $$new_props)
      $$invalidate(4, flip = $$new_props.flip);
    if ("label" in $$new_props)
      $$invalidate(5, label = $$new_props.label);
    if ("style" in $$new_props)
      $$invalidate(14, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Raw: Raw_default,
    Svg: Svg_default,
    className,
    data,
    iconData,
    scale,
    spin,
    inverse,
    pulse,
    flip,
    label,
    style,
    childrenHeight,
    childrenWidth,
    outerScale,
    width,
    height,
    combinedStyle,
    box,
    normaliseData,
    normalisedScale,
    calculateBox,
    calculateRatio,
    calculateWidth,
    calculateHeight,
    calculateStyle
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("data" in $$props)
      $$invalidate(12, data = $$new_props.data);
    if ("iconData" in $$props)
      $$invalidate(6, iconData = $$new_props.iconData);
    if ("scale" in $$props)
      $$invalidate(13, scale = $$new_props.scale);
    if ("spin" in $$props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("inverse" in $$props)
      $$invalidate(2, inverse = $$new_props.inverse);
    if ("pulse" in $$props)
      $$invalidate(3, pulse = $$new_props.pulse);
    if ("flip" in $$props)
      $$invalidate(4, flip = $$new_props.flip);
    if ("label" in $$props)
      $$invalidate(5, label = $$new_props.label);
    if ("style" in $$props)
      $$invalidate(14, style = $$new_props.style);
    if ("childrenHeight" in $$props)
      childrenHeight = $$new_props.childrenHeight;
    if ("childrenWidth" in $$props)
      childrenWidth = $$new_props.childrenWidth;
    if ("outerScale" in $$props)
      outerScale = $$new_props.outerScale;
    if ("width" in $$props)
      $$invalidate(7, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(8, height = $$new_props.height);
    if ("combinedStyle" in $$props)
      $$invalidate(9, combinedStyle = $$new_props.combinedStyle);
    if ("box" in $$props)
      $$invalidate(10, box = $$new_props.box);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*data, style, scale*/
    28672) {
      $: {
        $$invalidate(6, iconData = normaliseData(data));
        style;
        scale;
        $$invalidate(7, width = calculateWidth());
        $$invalidate(8, height = calculateHeight());
        $$invalidate(9, combinedStyle = calculateStyle());
        $$invalidate(10, box = calculateBox());
      }
    }
  };
  return [
    className,
    spin,
    inverse,
    pulse,
    flip,
    label,
    iconData,
    width,
    height,
    combinedStyle,
    box,
    $$restProps,
    data,
    scale,
    style,
    slots,
    raw_data_binding,
    $$scope
  ];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        class: 0,
        data: 12,
        scale: 13,
        spin: 1,
        inverse: 2,
        pulse: 3,
        flip: 4,
        label: 5,
        style: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment3.name
    });
  }
  get class() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverse() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverse(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pulse() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pulse(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flip() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;
export {
  Icon_default as Icon,
  Icon_default as default
};
//# sourceMappingURL=svelte-awesome.js.map
